// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: spooled.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	QueueService_Enqueue_FullMethodName       = "/spooled.v1.QueueService/Enqueue"
	QueueService_Dequeue_FullMethodName       = "/spooled.v1.QueueService/Dequeue"
	QueueService_Complete_FullMethodName      = "/spooled.v1.QueueService/Complete"
	QueueService_Fail_FullMethodName          = "/spooled.v1.QueueService/Fail"
	QueueService_RenewLease_FullMethodName    = "/spooled.v1.QueueService/RenewLease"
	QueueService_GetJob_FullMethodName        = "/spooled.v1.QueueService/GetJob"
	QueueService_GetQueueStats_FullMethodName = "/spooled.v1.QueueService/GetQueueStats"
	QueueService_StreamJobs_FullMethodName    = "/spooled.v1.QueueService/StreamJobs"
	QueueService_ProcessJobs_FullMethodName   = "/spooled.v1.QueueService/ProcessJobs"
)

// QueueServiceClient is the client API for QueueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Spooled Queue Service
// High-performance gRPC API for job queue operations
type QueueServiceClient interface {
	// Enqueue a new job
	Enqueue(ctx context.Context, in *EnqueueRequest, opts ...grpc.CallOption) (*EnqueueResponse, error)
	// Dequeue a job (for workers)
	Dequeue(ctx context.Context, in *DequeueRequest, opts ...grpc.CallOption) (*DequeueResponse, error)
	// Complete a job
	Complete(ctx context.Context, in *CompleteRequest, opts ...grpc.CallOption) (*CompleteResponse, error)
	// Fail a job
	Fail(ctx context.Context, in *FailRequest, opts ...grpc.CallOption) (*FailResponse, error)
	// Renew job lease
	RenewLease(ctx context.Context, in *RenewLeaseRequest, opts ...grpc.CallOption) (*RenewLeaseResponse, error)
	// Get job status
	GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error)
	// Get queue statistics
	GetQueueStats(ctx context.Context, in *GetQueueStatsRequest, opts ...grpc.CallOption) (*GetQueueStatsResponse, error)
	// Stream jobs to workers (server-side streaming)
	// Note: Streaming is implemented via REST API WebSocket/SSE endpoints:
	//   - GET /api/v1/ws (WebSocket for bidirectional real-time updates)
	//   - GET /api/v1/events (SSE for job event streaming)
	//   - GET /api/v1/events/jobs/{id} (SSE for single job updates)
	//   - GET /api/v1/events/queues/{name} (SSE for queue updates)
	StreamJobs(ctx context.Context, in *StreamJobsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Job], error)
	// Bidirectional streaming for real-time job processing
	// Note: Use WebSocket endpoint /api/v1/ws for bidirectional communication
	ProcessJobs(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ProcessRequest, ProcessResponse], error)
}

type queueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueServiceClient(cc grpc.ClientConnInterface) QueueServiceClient {
	return &queueServiceClient{cc}
}

func (c *queueServiceClient) Enqueue(ctx context.Context, in *EnqueueRequest, opts ...grpc.CallOption) (*EnqueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnqueueResponse)
	err := c.cc.Invoke(ctx, QueueService_Enqueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) Dequeue(ctx context.Context, in *DequeueRequest, opts ...grpc.CallOption) (*DequeueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DequeueResponse)
	err := c.cc.Invoke(ctx, QueueService_Dequeue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) Complete(ctx context.Context, in *CompleteRequest, opts ...grpc.CallOption) (*CompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompleteResponse)
	err := c.cc.Invoke(ctx, QueueService_Complete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) Fail(ctx context.Context, in *FailRequest, opts ...grpc.CallOption) (*FailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailResponse)
	err := c.cc.Invoke(ctx, QueueService_Fail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) RenewLease(ctx context.Context, in *RenewLeaseRequest, opts ...grpc.CallOption) (*RenewLeaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenewLeaseResponse)
	err := c.cc.Invoke(ctx, QueueService_RenewLease_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJobResponse)
	err := c.cc.Invoke(ctx, QueueService_GetJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetQueueStats(ctx context.Context, in *GetQueueStatsRequest, opts ...grpc.CallOption) (*GetQueueStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQueueStatsResponse)
	err := c.cc.Invoke(ctx, QueueService_GetQueueStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) StreamJobs(ctx context.Context, in *StreamJobsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Job], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &QueueService_ServiceDesc.Streams[0], QueueService_StreamJobs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamJobsRequest, Job]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QueueService_StreamJobsClient = grpc.ServerStreamingClient[Job]

func (c *queueServiceClient) ProcessJobs(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ProcessRequest, ProcessResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &QueueService_ServiceDesc.Streams[1], QueueService_ProcessJobs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ProcessRequest, ProcessResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QueueService_ProcessJobsClient = grpc.BidiStreamingClient[ProcessRequest, ProcessResponse]

// QueueServiceServer is the server API for QueueService service.
// All implementations must embed UnimplementedQueueServiceServer
// for forward compatibility.
//
// Spooled Queue Service
// High-performance gRPC API for job queue operations
type QueueServiceServer interface {
	// Enqueue a new job
	Enqueue(context.Context, *EnqueueRequest) (*EnqueueResponse, error)
	// Dequeue a job (for workers)
	Dequeue(context.Context, *DequeueRequest) (*DequeueResponse, error)
	// Complete a job
	Complete(context.Context, *CompleteRequest) (*CompleteResponse, error)
	// Fail a job
	Fail(context.Context, *FailRequest) (*FailResponse, error)
	// Renew job lease
	RenewLease(context.Context, *RenewLeaseRequest) (*RenewLeaseResponse, error)
	// Get job status
	GetJob(context.Context, *GetJobRequest) (*GetJobResponse, error)
	// Get queue statistics
	GetQueueStats(context.Context, *GetQueueStatsRequest) (*GetQueueStatsResponse, error)
	// Stream jobs to workers (server-side streaming)
	// Note: Streaming is implemented via REST API WebSocket/SSE endpoints:
	//   - GET /api/v1/ws (WebSocket for bidirectional real-time updates)
	//   - GET /api/v1/events (SSE for job event streaming)
	//   - GET /api/v1/events/jobs/{id} (SSE for single job updates)
	//   - GET /api/v1/events/queues/{name} (SSE for queue updates)
	StreamJobs(*StreamJobsRequest, grpc.ServerStreamingServer[Job]) error
	// Bidirectional streaming for real-time job processing
	// Note: Use WebSocket endpoint /api/v1/ws for bidirectional communication
	ProcessJobs(grpc.BidiStreamingServer[ProcessRequest, ProcessResponse]) error
	mustEmbedUnimplementedQueueServiceServer()
}

// UnimplementedQueueServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQueueServiceServer struct{}

func (UnimplementedQueueServiceServer) Enqueue(context.Context, *EnqueueRequest) (*EnqueueResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Enqueue not implemented")
}
func (UnimplementedQueueServiceServer) Dequeue(context.Context, *DequeueRequest) (*DequeueResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Dequeue not implemented")
}
func (UnimplementedQueueServiceServer) Complete(context.Context, *CompleteRequest) (*CompleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Complete not implemented")
}
func (UnimplementedQueueServiceServer) Fail(context.Context, *FailRequest) (*FailResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Fail not implemented")
}
func (UnimplementedQueueServiceServer) RenewLease(context.Context, *RenewLeaseRequest) (*RenewLeaseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RenewLease not implemented")
}
func (UnimplementedQueueServiceServer) GetJob(context.Context, *GetJobRequest) (*GetJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedQueueServiceServer) GetQueueStats(context.Context, *GetQueueStatsRequest) (*GetQueueStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetQueueStats not implemented")
}
func (UnimplementedQueueServiceServer) StreamJobs(*StreamJobsRequest, grpc.ServerStreamingServer[Job]) error {
	return status.Error(codes.Unimplemented, "method StreamJobs not implemented")
}
func (UnimplementedQueueServiceServer) ProcessJobs(grpc.BidiStreamingServer[ProcessRequest, ProcessResponse]) error {
	return status.Error(codes.Unimplemented, "method ProcessJobs not implemented")
}
func (UnimplementedQueueServiceServer) mustEmbedUnimplementedQueueServiceServer() {}
func (UnimplementedQueueServiceServer) testEmbeddedByValue()                      {}

// UnsafeQueueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueServiceServer will
// result in compilation errors.
type UnsafeQueueServiceServer interface {
	mustEmbedUnimplementedQueueServiceServer()
}

func RegisterQueueServiceServer(s grpc.ServiceRegistrar, srv QueueServiceServer) {
	// If the following call panics, it indicates UnimplementedQueueServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QueueService_ServiceDesc, srv)
}

func _QueueService_Enqueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Enqueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Enqueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Enqueue(ctx, req.(*EnqueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_Dequeue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DequeueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Dequeue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Dequeue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Dequeue(ctx, req.(*DequeueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_Complete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Complete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Complete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Complete(ctx, req.(*CompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_Fail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Fail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Fail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Fail(ctx, req.(*FailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_RenewLease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewLeaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).RenewLease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_RenewLease_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).RenewLease(ctx, req.(*RenewLeaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_GetJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetJob(ctx, req.(*GetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetQueueStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQueueStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetQueueStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_GetQueueStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetQueueStats(ctx, req.(*GetQueueStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_StreamJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamJobsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueueServiceServer).StreamJobs(m, &grpc.GenericServerStream[StreamJobsRequest, Job]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QueueService_StreamJobsServer = grpc.ServerStreamingServer[Job]

func _QueueService_ProcessJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QueueServiceServer).ProcessJobs(&grpc.GenericServerStream[ProcessRequest, ProcessResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QueueService_ProcessJobsServer = grpc.BidiStreamingServer[ProcessRequest, ProcessResponse]

// QueueService_ServiceDesc is the grpc.ServiceDesc for QueueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "spooled.v1.QueueService",
	HandlerType: (*QueueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Enqueue",
			Handler:    _QueueService_Enqueue_Handler,
		},
		{
			MethodName: "Dequeue",
			Handler:    _QueueService_Dequeue_Handler,
		},
		{
			MethodName: "Complete",
			Handler:    _QueueService_Complete_Handler,
		},
		{
			MethodName: "Fail",
			Handler:    _QueueService_Fail_Handler,
		},
		{
			MethodName: "RenewLease",
			Handler:    _QueueService_RenewLease_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _QueueService_GetJob_Handler,
		},
		{
			MethodName: "GetQueueStats",
			Handler:    _QueueService_GetQueueStats_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamJobs",
			Handler:       _QueueService_StreamJobs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProcessJobs",
			Handler:       _QueueService_ProcessJobs_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "spooled.proto",
}

const (
	WorkerService_Register_FullMethodName   = "/spooled.v1.WorkerService/Register"
	WorkerService_Heartbeat_FullMethodName  = "/spooled.v1.WorkerService/Heartbeat"
	WorkerService_Deregister_FullMethodName = "/spooled.v1.WorkerService/Deregister"
)

// WorkerServiceClient is the client API for WorkerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Worker Service for worker management
type WorkerServiceClient interface {
	// Register a new worker
	Register(ctx context.Context, in *RegisterWorkerRequest, opts ...grpc.CallOption) (*RegisterWorkerResponse, error)
	// Send heartbeat
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// Deregister worker
	Deregister(ctx context.Context, in *DeregisterRequest, opts ...grpc.CallOption) (*DeregisterResponse, error)
}

type workerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerServiceClient(cc grpc.ClientConnInterface) WorkerServiceClient {
	return &workerServiceClient{cc}
}

func (c *workerServiceClient) Register(ctx context.Context, in *RegisterWorkerRequest, opts ...grpc.CallOption) (*RegisterWorkerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterWorkerResponse)
	err := c.cc.Invoke(ctx, WorkerService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, WorkerService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerServiceClient) Deregister(ctx context.Context, in *DeregisterRequest, opts ...grpc.CallOption) (*DeregisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeregisterResponse)
	err := c.cc.Invoke(ctx, WorkerService_Deregister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServiceServer is the server API for WorkerService service.
// All implementations must embed UnimplementedWorkerServiceServer
// for forward compatibility.
//
// Worker Service for worker management
type WorkerServiceServer interface {
	// Register a new worker
	Register(context.Context, *RegisterWorkerRequest) (*RegisterWorkerResponse, error)
	// Send heartbeat
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// Deregister worker
	Deregister(context.Context, *DeregisterRequest) (*DeregisterResponse, error)
	mustEmbedUnimplementedWorkerServiceServer()
}

// UnimplementedWorkerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkerServiceServer struct{}

func (UnimplementedWorkerServiceServer) Register(context.Context, *RegisterWorkerRequest) (*RegisterWorkerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedWorkerServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedWorkerServiceServer) Deregister(context.Context, *DeregisterRequest) (*DeregisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Deregister not implemented")
}
func (UnimplementedWorkerServiceServer) mustEmbedUnimplementedWorkerServiceServer() {}
func (UnimplementedWorkerServiceServer) testEmbeddedByValue()                       {}

// UnsafeWorkerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerServiceServer will
// result in compilation errors.
type UnsafeWorkerServiceServer interface {
	mustEmbedUnimplementedWorkerServiceServer()
}

func RegisterWorkerServiceServer(s grpc.ServiceRegistrar, srv WorkerServiceServer) {
	// If the following call panics, it indicates UnimplementedWorkerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkerService_ServiceDesc, srv)
}

func _WorkerService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).Register(ctx, req.(*RegisterWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerService_Deregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeregisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).Deregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerService_Deregister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).Deregister(ctx, req.(*DeregisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkerService_ServiceDesc is the grpc.ServiceDesc for WorkerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "spooled.v1.WorkerService",
	HandlerType: (*WorkerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _WorkerService_Register_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _WorkerService_Heartbeat_Handler,
		},
		{
			MethodName: "Deregister",
			Handler:    _WorkerService_Deregister_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "spooled.proto",
}
